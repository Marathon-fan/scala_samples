
# hello-lagom


//--------------------------------

singleton Design Pattern  

Builder Design Pattern  

Factory Method  

Abstract Factory Method  


This project has been generated by the lagom/lagom-scala.g8 template. 

For instructions on running and testing the project, see https://www.lagomframework.com/get-started-scala.html.


//--------------------------------


//------  
events int the System  

```scala
trait HelloEvent extends Jsonable

object HelloEvent {
	case class GreetingMessageChanged (message: String) extends HelloEvent {
		require(message != null, "message must not be null")
	}
}

```

//------  
commands in the system  

```scala
sealed trait HelloCommand extends Jsonable 

object HelloCommand {

	case class UserGreetingMessage(message: String) extends HelloCommand with compressedJasonable with PersistentEntity.ReplyType[Done] {
		require(message != null, "message must not be null")
	}

	case class Hello(name: String, organization: Option[String]) extends HelloCommand with PersistentEntity.ReplyType[String] {
		require(name != null, "name must not be null")
		require(organization != null, "organization must not be null")
	}

}


```

//------  
State in the system 

```scala
// the state for the {@link HelloWorld} entity  
case class WorldState (message: String, timestamp: String) extends CompressedJsonable {
	require(message != null, "message must not null")
	require(timestamp != null, "timestamp must not be null")
}

```

//------  
put command, event and state together  
```scala
class HelloWorld extends PersistentEntity[HelloCommand, HelloEvent, WorldState] {

	def initialBehavior(sanpshotState: Optional[WorldState]): Behavior = {
		var b: BehaviorBuilder = newBehaviorBuilder(snapshotState.orElse(new WorldState("hello", LocalDateTime.now.toString)))  // link state

		import scala.compat.java8.FunctionConverters._

		b.setCommandHandler[Done, UserGreetingMessage](classOf[HelloCommand.UseGreetingMessage],                                // link command  
			asJavaBiFunction((cmd, ctx) => ctx.thenPresist[HelloEvent](
				GreetingMessageChanged(cmd.message),                                                                            // message queue?
				asJavaConsumer((event: HelloEvent) => ctx.reply(Done.getInstance()))                                            // consumer 

				)))

        // event handler for the GreetingMessageChanged event  
		b.setEventHandler[HelloEvent.GreetingMessageChanged](...)                                                               // 
		//...

	}

}


```


//--------------------------------



//--------------------------------
message-driven processing  

Message-driven processing is an approach used within the client/server computing model in which a client (for example, your Web browser) sends a service request in the form of a specially-formatted message to a program that acts as a request broker, handling messages from many clients intended for many different server applications. A message may contain the name of the service (application) wanted and possibly a requested priority or time of forwarding. The request broker manages a queue of requests (and possibly replies) and screens the details of different kinds of clients and servers from each other. Both client and server need only understand the messaging interface. 

Message-driven processing is often used in distributed computing in a geographically-dispersed network and as a way to screen new client applications from having to interact directly with legacy server applications. Special software that provides message-driven processing is known as middleware.





//--------------------------------  

```
// some kind of stateful microservice. The greeting info(first was "Hi", then was "Whatsup") can be stored in external database
GET - api/hello/Alice -> Hi Alice  
POST - api/hello/Alice {"message": "Whatsup"}  
GET - api/hello/Alice -> Whatsup Alice  

```


//--------------------------------
Jsonable(lagom)  
Jsonable(Marker interface for messages that are serialized as JSON.)  

com.lightbend.lagom.serialization
Interface Jsonable

All Superinterfaces:
java.io.Serializable
All Known Subinterfaces:
CompressedJsonable

public interface Jsonable
extends scala.Serializable

It extends java.io.Serializable to give it higher priority than JavaSerializer in Akka in case message class implements both interfaces.

//--------------------------------  
Behavior(lagom)    

com.lightbend.lagom.javadsl.persistence
Class PersistentEntity.Behavior

Behavior consists of current state and functions to process incoming commands and persisted events. Behavior is an immutable class. Use the mutable BehaviorBuilder for defining command and event handlers.

commandHandlers  
```scala
public scala.collection.immutable.Map<Class<? extends Command>,java.util.function.BiFunction<? extends Command,PersistentEntity.CommandContext<Object>,PersistentEntity.Persist<? extends Event>>> commandHandlers()
```

//--------------------------------
newBehaviorBuilder(lagom)  

Use newBehaviorBuilder to create a mutable builder for defining the behavior. The behavior consists of current state and functions to process incoming commands and persisted events as described in the following sections.

```scala
import com.lightbend.lagom.javadsl.persistence.PersistentEntity;

public class Post1
  extends PersistentEntity<BlogCommand, BlogEvent, BlogState> {

  @Override
  public Behavior initialBehavior(Optional<BlogState> snapshotState) {
    BehaviorBuilder b = newBehaviorBuilder(
        snapshotState.orElse(BlogState.EMPTY));

    // TODO define command and event handlers

    return b.build();
  }

}
```
The three type parameters of the extended PersistentEntity class define:

Command - the super class/interface of the commands  
Event - the super class/interface of the events  
State - the class of the state  



//--------------------------------  

asJavaFunction  
asJavaBiFunction
asJavaConsumer  
asJavaBiConsumer  

asJavaFunction  
```scala  
implicit def asJavaFunction[T, R](sFun: T => R): java.util.function.Function[T, R] =
    new java.util.function.Function[T, R] {
      override def apply(t: T): R = sFun(t)
    }
```

asJavaBiFunction  
```scala
  implicit def asJavaBiFunction[T, U, R](sFun: (T, U) => R): java.util.function.BiFunction[T, U, R] =
    new java.util.function.BiFunction[T, U, R] {
      override def apply(t: T, u: U): R = sFun(t, u)
    }
```


asJavaConsumer
```scala
  implicit def asJavaConsumer[T](sFun: T => Unit): java.util.function.Consumer[T] =
    new java.util.function.Consumer[T] {
      override def accept(t: T): Unit = sFun(t)
    }
```


asJavaBiConsumer
```scala
  implicit def asJavaBiConsumer[T, U](sFun: (T, U) => Unit): java.util.function.BiConsumer[T, U] =
    new java.util.function.BiConsumer[T, U] {
      override def accept(t: T, u: U): Unit = sFun(t, u)
    }
```

//--------------------------------  
Descriptor(lagom)  

A descriptor is a set of call and topic descriptors that the service provides, coupled with metadata about how the service and its calls are to be served. Metadata may include versioning and migrations, SLA's, sharding hints, circuit breaker strategies etc.


Behavior consists of current state and functions to process incoming commands and persisted events. Behavior is an immutable class. Use the mutable BehaviorBuilder for defining command and event handlers.



//--------------------------------  
Predef(scala)  

object Predef extends LowPriorityImplicits with DeprecatedPredef
The Predef object provides definitions that are accessible in all Scala compilation units without explicit qualification.

Commonly Used Types

Predef provides type aliases for types which are commonly used, such as the immutable collection types scala.collection.immutable.Map, scala.collection.immutable.Set, and the scala.collection.immutable.List constructors (scala.collection.immutable.:: and scala.collection.immutable.Nil).  


//--------------------------------
@Inject()   ----scala Dependency Injection  
If you have a component, such as a controller, and it requires some other components as dependencies, then this can be declared using the @Inject annotation. The @Inject annotation can be used on fields or on constructors. We recommend that you use it on constructors, for example:

```scala
import javax.inject._
import play.api.libs.ws._

class MyComponent @Inject() (ws: WSClient) {
  // ...
}
``` 

Note that the @Inject annotation must come after the class name but before the constructor parameters, and must have parentheses.

Also, Guice does come with several other types of injections, but constructor injection is generally the most clear, concise, and testable in Scala, so we recommend using it.

Guice is able to automatically instantiate any class with an @Inject on its constructor without having to explicitly bind it. This feature is called just in time bindings is described in more detail in the Guice documentation. If you need to do something more sophisticated you can declare a custom binding as described below.


//--------------------------------  
Done(Akka)    

sealed abstract class Done extends Serializable
Typically used together with Future to signal completion but there is no actual value completed. More clearly signals intent than Unit and is available both from Scala and Java (which Unit is not).


```scala
// done source code

package akka

import java.io.Serializable
import akka.annotation.DoNotInherit

/**
 * Typically used together with `Future` to signal completion
 * but there is no actual value completed. More clearly signals intent
 * than `Unit` and is available both from Scala and Java (which `Unit` is not).
 */
@DoNotInherit sealed abstract class Done extends Serializable

case object Done extends Done {
  /**
   * Java API: the singleton instance
   */
  def getInstance(): Done = this
}

```




//--------------------------------
actor  
In the actor model – as conceived in 1973 by Carl Hewitt et al. – actors are “fundamental units of computation that embody processing, storage and communication”.   

In a nutshell, 
communication means asynchronous messaging,   
storage means that actors can have state and   
processing simply means that actors can handle messages, which is also known as behavior.   


an Akka actor is made up of several collaborating components. 
The ActorRef represents the logical address of an actor and enables us to asynchronously send messages to the actor in a fire-and-forget manner.  
The dispatcher – by default there is one per actor system – takes care of enqueuing messages into the mailbox of an actor as well as scheduling the mailbox for dequeuing one or more messages – but only one at a time – to be processed by the actor. 
Last but not least, the Actor – typically the only API we have to implement – encapsulates state and behavior.  

//see pictures here  
https://blog.codecentric.de/en/2015/08/introduction-to-akka-actors/


//--------------------------------  
akka.actor.ActorSystem

An actor system is a hierarchical group of actors which share common configuration, e.g. dispatchers, deployments, remote capabilities and addresses. It is also the entry point for creating or looking up actors.



```scala
// Java or Scala
system.actorOf(props, "name")
system.actorOf(props)

// Scala
system.actorOf(Props[MyActor], "name")
system.actorOf(Props(classOf[MyActor], arg1, arg2), "name")

// Java
system.actorOf(Props.create(MyActor.class), "name");
system.actorOf(Props.create(MyActor.class, arg1, arg2), "name");
```




##  create a lagom project using scala  
https://developer.lightbend.com/start/?group=lagom&project=lagom-scala-sbt  






//--------------------------------  

```scala
case class GreetingMessage(message: String) {
	require(message != null, "message must not be null")
}
```


//--------------------------------
Model your complex domain data for scale and simplicity with CQRS and Event Sourcing


//--------------------------------  
LAGOM: Managing Data Persistence

Each service has its own data. 


Event Sourcing - storing deltas  
1 every state change is materialized in an event  
2 all events are stored in an Event Log  
3 current state is constructed by replaying all events  

Event Sourcing - storing deltas  

Event sourcing - benefits  
1 no object-relational impedance mismatch  
2 bullet-proof auditing and historical tracing  
3 support future ways of looking at data  
4 performance and scalability  
5 testability  

Event sourcing - rolling snapshots  


Persistent Entity  


CQRS - benefits  
// https://www.lagomframework.com/  
1 separation(between the concerns of the writing and reading side)  
an entity can focuse on updating command  
the reading side can be optimized for various quries and recording jobs  

2 scalability  
because of separation, the read side can be scaled out to many nodes independently of the write side   
it is often on the read side you need this massive scalability  



//--------------------------------  
LAGOM: FIRST IMPRESSIONS AND INITIAL COMPARISON TO SPRING CLOUD  
https://ordina-jworks.github.io/microservices/2016/04/22/Lagom-First-Impressions-and-Initial-Comparison-to-Spring-Cloud.html



//--------------------------------
CQRS  

CQRS stands for Command Query Responsibility Segregation.  
It's a pattern that I first heard described by Greg Young. At its heart is the notion that you can use a different model to update information than the model you use to read information. For some situations, this separation can be valuable, but beware that for most systems CQRS adds risky complexity.  

Command Query Responsibility Segregation (CQRS) is an architectural pattern that separates reading and writing into two different models. This means that every method should either be a Command that performs an action or a Query that returns data.  

https://msdn.microsoft.com/en-us/library/jj591573.aspx  
https://martinfowler.com/bliki/CQRS.html


//--------------------------------
Event Sourcing   

Event Sourcing pattern defines an approach to handling operations on data that's driven by a sequence of events, each of which is recorded in an append-only store. Application code sends a series of events that imperatively describe each action that has occurred on the data to the event store, where they're persisted. Each event represents a set of changes to the data (such as AddedItemToOrder).

http://microservices.io/patterns/data/event-sourcing.html  
https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing  